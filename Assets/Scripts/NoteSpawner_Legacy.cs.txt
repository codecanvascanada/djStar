using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class NoteSpawner_Legacy : MonoBehaviour
{
    [Header("Song Data")]
    public SongData currentSong;

    [Header("Spawning Info")]
    public GameObject notePrefab;
    public Transform[] laneSpawnPoints;
    [Tooltip("Delay before the song and notes start, allowing player to prepare.")]
    public float startDelay = 4f;

    [Header("Note Materials")]
    public Material tapNoteMaterial;
    public Material holdNoteMaterial;

    private float noteTravelTime; 
    private int nextNoteIndex = 0;

    void Start()
    {
        if (currentSong == null)
        {
            Debug.LogError("No SongData assigned to NoteSpawner!");
            this.enabled = false;
            return;
        }

        if (laneSpawnPoints.Length > 0 && notePrefab != null)
        {
            float distance = laneSpawnPoints[0].position.z;
            float speed = notePrefab.GetComponent<Note>().speed;
            if (speed > 0)
            {
                noteTravelTime = distance / speed;
            }
        }

        StartCoroutine(StartGameSequence());
    }

    private IEnumerator StartGameSequence()
    {
        GameManager.Instance.isGameActive = false;

        if (currentSong.audioClip.loadState != AudioDataLoadState.Loaded)
        {
            Debug.Log("Audio clip is not loaded. Forcing load...");
            currentSong.audioClip.LoadAudioData();
            while (currentSong.audioClip.loadState == AudioDataLoadState.Loading)
            {
                yield return null;
            }
            if (currentSong.audioClip.loadState != AudioDataLoadState.Loaded)
            {
                Debug.LogError("Failed to load audio clip. Halting game start.");
                yield break;
            }
            Debug.Log("Audio clip loaded successfully!");
        }

        bool isRecordMode = (currentSong.notes.Count == 0);
        GameManager.Instance.isRecordMode = isRecordMode;
        nextNoteIndex = 0;

        // Schedule the music to play, and record the exact start time.
        GameManager.Instance.songStartTime = (float)AudioSettings.dspTime + startDelay;
        GameManager.Instance.musicSource.clip = currentSong.audioClip;
        GameManager.Instance.musicSource.PlayScheduled(GameManager.Instance.songStartTime);

        // --- Silent Pre-Spawning Loop ---
        float waitTimer = startDelay;
        while (waitTimer > 0)
        {
            // In playback mode, spawn notes that should appear during the delay
            if (!isRecordMode)
            {
                float songPosition = (float)AudioSettings.dspTime - GameManager.Instance.songStartTime;
#if UNITY_WEBGL
                songPosition += GameManager.Instance.webglSyncOffset;
#endif
                while (nextNoteIndex < currentSong.notes.Count && 
                       currentSong.notes[nextNoteIndex].timeToHit < songPosition + noteTravelTime)
                {
                    SpawnNoteFor(currentSong.notes[nextNoteIndex], songPosition);
                    nextNoteIndex++;
                }
            }

            yield return null;
            waitTimer -= Time.deltaTime;
        }

        // --- Game Starts for Real ---
        GameManager.Instance.isGameActive = true;
    }

    void Update()
    {
        // This Update loop handles all note spawning.
        if (GameManager.Instance.isRecordMode || !GameManager.Instance.isGameActive || currentSong == null || nextNoteIndex >= currentSong.notes.Count)
        {
            return;
        }

        float songPosition = (float)AudioSettings.dspTime - GameManager.Instance.songStartTime;
#if UNITY_WEBGL
        songPosition += GameManager.Instance.webglSyncOffset;
#endif

        while (nextNoteIndex < currentSong.notes.Count && 
               currentSong.notes[nextNoteIndex].timeToHit < songPosition + noteTravelTime)
        {
            SpawnNoteFor(currentSong.notes[nextNoteIndex], songPosition);
            nextNoteIndex++;
        }
    }

    void SpawnNoteFor(NoteData noteData, float currentSongPos)
    {
        if (noteData.laneIndex < 0 || noteData.laneIndex >= laneSpawnPoints.Length)
        {
            Debug.LogError($"Invalid lane index: {noteData.laneIndex}");
            return;
        }

        Transform spawnPoint = laneSpawnPoints[noteData.laneIndex];
        GameObject noteObject = Instantiate(notePrefab, spawnPoint.position, Quaternion.identity);
        
        Note noteScript = noteObject.GetComponent<Note>();
        if (noteScript != null)
        {
            float timeSinceSpawn = currentSongPos - (noteData.timeToHit - noteTravelTime);
            
            if (timeSinceSpawn > 0)
            {
                noteObject.transform.position += Vector3.back * noteScript.speed * timeSinceSpawn;
            }

            noteScript.Setup(noteData);

            MeshRenderer visualRenderer = noteScript.visual.GetComponent<MeshRenderer>();
            if (visualRenderer != null)
            {
                visualRenderer.material = (noteData.noteType == NoteType.Hold) ? holdNoteMaterial : tapNoteMaterial;
            }
        }
    }
}
